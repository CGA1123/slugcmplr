// Code generated by sqlc. DO NOT EDIT.
// source: builds.sql

package store

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const claimReceiveToken = `-- name: ClaimReceiveToken :exec
UPDATE receive_tokens
SET claimed_at = NOW()
WHERE claimed_at IS NULL
AND build_request_target = $1
AND build_request_id = $2
`

type ClaimReceiveTokenParams struct {
	BuildRequestTarget string
	BuildRequestID     uuid.UUID
}

func (q *Queries) ClaimReceiveToken(ctx context.Context, arg ClaimReceiveTokenParams) error {
	_, err := q.db.Exec(ctx, claimReceiveToken, arg.BuildRequestTarget, arg.BuildRequestID)
	return err
}

const createBuildRequest = `-- name: CreateBuildRequest :one
INSERT INTO build_requests (
  id,
  targets,
  commit_sha,
  tree_sha,
  owner,
  repository,
  created_at,
  updated_at
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  NOW(),
  NOW()
)
ON CONFLICT (id) DO UPDATE
SET updated_at = NOW()
RETURNING id
`

type CreateBuildRequestParams struct {
	ID         uuid.UUID
	Targets    []string
	CommitSha  string
	TreeSha    string
	Owner      string
	Repository string
}

func (q *Queries) CreateBuildRequest(ctx context.Context, arg CreateBuildRequestParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createBuildRequest,
		arg.ID,
		arg.Targets,
		arg.CommitSha,
		arg.TreeSha,
		arg.Owner,
		arg.Repository,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createBuildToken = `-- name: CreateBuildToken :one
INSERT INTO build_tokens (
  build_request_id,
  build_request_target,
  token,
  id,
  created_at
)
VALUES (
  $1,
  $2,
  $3,
  uuid_generate_v4(),
  NOW()
)
RETURNING id
`

type CreateBuildTokenParams struct {
	BuildRequestID     uuid.UUID
	BuildRequestTarget string
	Token              string
}

func (q *Queries) CreateBuildToken(ctx context.Context, arg CreateBuildTokenParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createBuildToken, arg.BuildRequestID, arg.BuildRequestTarget, arg.Token)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createReceiveToken = `-- name: CreateReceiveToken :one
INSERT INTO receive_tokens (
  build_request_id,
  build_request_target,
  token,
  id,
  created_at
)
VALUES (
  $1,
  $2,
  $3,
  uuid_generate_v4(),
  NOW()
)
RETURNING id
`

type CreateReceiveTokenParams struct {
	BuildRequestID     uuid.UUID
	BuildRequestTarget string
	Token              string
}

func (q *Queries) CreateReceiveToken(ctx context.Context, arg CreateReceiveTokenParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createReceiveToken, arg.BuildRequestID, arg.BuildRequestTarget, arg.Token)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const expireBuildToken = `-- name: ExpireBuildToken :exec
UPDATE build_tokens
SET expired_at = NOW()
WHERE expired_at IS NULL
AND build_request_id = $1
AND build_request_target = $2
`

type ExpireBuildTokenParams struct {
	BuildRequestID     uuid.UUID
	BuildRequestTarget string
}

func (q *Queries) ExpireBuildToken(ctx context.Context, arg ExpireBuildTokenParams) error {
	_, err := q.db.Exec(ctx, expireBuildToken, arg.BuildRequestID, arg.BuildRequestTarget)
	return err
}

const getBuildRequest = `-- name: GetBuildRequest :one
SELECT id, targets, created_at, updated_at, commit_sha, tree_sha, owner, repository
FROM build_requests
WHERE id = $1
`

func (q *Queries) GetBuildRequest(ctx context.Context, id uuid.UUID) (BuildRequest, error) {
	row := q.db.QueryRow(ctx, getBuildRequest, id)
	var i BuildRequest
	err := row.Scan(
		&i.ID,
		&i.Targets,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CommitSha,
		&i.TreeSha,
		&i.Owner,
		&i.Repository,
	)
	return i, err
}

const getBuildRequestFromBuildToken = `-- name: GetBuildRequestFromBuildToken :one
SELECT b.id, b.targets, b.created_at, b.updated_at, b.commit_sha, b.tree_sha, b.owner, b.repository, T.build_request_target AS target
FROM build_requests B
JOIN build_tokens T ON B.id = T.build_request_id
WHERE T.token = $1
AND T.expired_at IS NULL
`

type GetBuildRequestFromBuildTokenRow struct {
	ID         uuid.UUID
	Targets    []string
	CreatedAt  time.Time
	UpdatedAt  time.Time
	CommitSha  string
	TreeSha    string
	Owner      string
	Repository string
	Target     string
}

func (q *Queries) GetBuildRequestFromBuildToken(ctx context.Context, token string) (GetBuildRequestFromBuildTokenRow, error) {
	row := q.db.QueryRow(ctx, getBuildRequestFromBuildToken, token)
	var i GetBuildRequestFromBuildTokenRow
	err := row.Scan(
		&i.ID,
		&i.Targets,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CommitSha,
		&i.TreeSha,
		&i.Owner,
		&i.Repository,
		&i.Target,
	)
	return i, err
}

const getBuildRequestFromReceiveToken = `-- name: GetBuildRequestFromReceiveToken :one
SELECT b.id, b.targets, b.created_at, b.updated_at, b.commit_sha, b.tree_sha, b.owner, b.repository, T.build_request_target AS target
FROM build_requests B
JOIN receive_tokens T ON B.id = T.build_request_id
WHERE T.token = $1
AND T.claimed_at IS NULL
`

type GetBuildRequestFromReceiveTokenRow struct {
	ID         uuid.UUID
	Targets    []string
	CreatedAt  time.Time
	UpdatedAt  time.Time
	CommitSha  string
	TreeSha    string
	Owner      string
	Repository string
	Target     string
}

func (q *Queries) GetBuildRequestFromReceiveToken(ctx context.Context, token string) (GetBuildRequestFromReceiveTokenRow, error) {
	row := q.db.QueryRow(ctx, getBuildRequestFromReceiveToken, token)
	var i GetBuildRequestFromReceiveTokenRow
	err := row.Scan(
		&i.ID,
		&i.Targets,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CommitSha,
		&i.TreeSha,
		&i.Owner,
		&i.Repository,
		&i.Target,
	)
	return i, err
}
