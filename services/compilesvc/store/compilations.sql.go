// Code generated by sqlc. DO NOT EDIT.
// source: compilations.sql

package store

import (
	"context"
)

const create = `-- name: Create :exec
INSERT INTO compilations (
  event_id,
  target,
  commit_sha,
  tree_sha,
  owner,
  repository,
  created_at,
  updated_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  NOW(),
  NOW()
)
`

type CreateParams struct {
	EventID    string
	Target     string
	CommitSha  string
	TreeSha    string
	Owner      string
	Repository string
}

func (q *Queries) Create(ctx context.Context, arg CreateParams) error {
	_, err := q.db.Exec(ctx, create,
		arg.EventID,
		arg.Target,
		arg.CommitSha,
		arg.TreeSha,
		arg.Owner,
		arg.Repository,
	)
	return err
}

const createToken = `-- name: CreateToken :exec
INSERT INTO compilation_tokens (
  event_id,
  target,
  token,
  created_at
) VALUES (
  $1,
  $2,
  $3,
  NOW()
)
`

type CreateTokenParams struct {
	EventID string
	Target  string
	Token   string
}

func (q *Queries) CreateToken(ctx context.Context, arg CreateTokenParams) error {
	_, err := q.db.Exec(ctx, createToken, arg.EventID, arg.Target, arg.Token)
	return err
}

const expireToken = `-- name: ExpireToken :exec
UPDATE compilation_tokens
SET expired_at = NOW()
WHERE token = $1
`

func (q *Queries) ExpireToken(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, expireToken, token)
	return err
}

const fetchWithToken = `-- name: FetchWithToken :one
SELECT c.event_id, c.target, c.commit_sha, c.tree_sha, c.owner, c.repository, c.created_at
FROM compilations C
JOIN compilation_tokens CT
ON CT.event_id = C.event_id
AND CT.target = C.target
WHERE CT.token = $1
AND CT.expired_at IS NULL
LIMIT 1
`

func (q *Queries) FetchWithToken(ctx context.Context, token string) (Compilation, error) {
	row := q.db.QueryRow(ctx, fetchWithToken, token)
	var i Compilation
	err := row.Scan(
		&i.EventID,
		&i.Target,
		&i.CommitSha,
		&i.TreeSha,
		&i.Owner,
		&i.Repository,
		&i.CreatedAt,
	)
	return i, err
}
