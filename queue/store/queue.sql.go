// Code generated by sqlc. DO NOT EDIT.
// source: queue.sql

package store

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const deadLetter = `-- name: DeadLetter :exec
INSERT INTO dead_jobs (
  id,
  queue_name,
  queued_at,
  scheduled_at,
  data,
  attempt
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6
)
`

type DeadLetterParams struct {
	ID          uuid.UUID
	QueueName   string
	QueuedAt    time.Time
	ScheduledAt time.Time
	Data        []byte
	Attempt     int32
}

func (q *Queries) DeadLetter(ctx context.Context, arg DeadLetterParams) error {
	_, err := q.db.Exec(ctx, deadLetter,
		arg.ID,
		arg.QueueName,
		arg.QueuedAt,
		arg.ScheduledAt,
		arg.Data,
		arg.Attempt,
	)
	return err
}

const deadLetterCount = `-- name: DeadLetterCount :one
SELECT COUNT(*) FROM dead_jobs
`

func (q *Queries) DeadLetterCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, deadLetterCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const dequeue = `-- name: Dequeue :one
DELETE FROM queued_jobs
USING (
  SELECT id, queue_name, queued_at, scheduled_at, data, attempt
  FROM queued_jobs
  WHERE queued_jobs.queue_name = $1
  ORDER BY scheduled_at ASC
  LIMIT 1
  FOR UPDATE SKIP LOCKED
) jobs
WHERE jobs.id = queued_jobs.id
RETURNING queued_jobs.id, queued_jobs.queue_name, queued_jobs.queued_at, queued_jobs.scheduled_at, queued_jobs.data, queued_jobs.attempt
`

func (q *Queries) Dequeue(ctx context.Context, queueName string) (QueuedJob, error) {
	row := q.db.QueryRow(ctx, dequeue, queueName)
	var i QueuedJob
	err := row.Scan(
		&i.ID,
		&i.QueueName,
		&i.QueuedAt,
		&i.ScheduledAt,
		&i.Data,
		&i.Attempt,
	)
	return i, err
}

const enqueue = `-- name: Enqueue :one
INSERT INTO queued_jobs (
  id,
  queue_name,
  queued_at,
  scheduled_at,
  data,
  attempt
) VALUES (
  uuid_generate_v4(),
  $1,
  NOW(),
  $2,
  $3,
  $4
)
RETURNING id
`

type EnqueueParams struct {
	QueueName   string
	ScheduledAt time.Time
	Data        []byte
	Attempt     int32
}

func (q *Queries) Enqueue(ctx context.Context, arg EnqueueParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, enqueue,
		arg.QueueName,
		arg.ScheduledAt,
		arg.Data,
		arg.Attempt,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
